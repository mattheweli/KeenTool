#!/bin/sh

# ==============================================================================
# KEENTOOL MANAGER v0.6.7 (BETA)
# Author: MatthewEli
# Features:
#   - FIX: Logging modules toggle correctly (fixed grep detection logic).
#   - UX: Cron jobs are now displayed in human-readable format.
#   - MENU: Dynamic status indicators for Email and Auto-Update schedule.
#   - EMAIL: Native SMTP notifications (TLS/SSL) with encrypted password.
# ==============================================================================

export PATH=/opt/bin:/opt/sbin:/usr/bin:/usr/sbin:/bin:/sbin

# --- CONFIGURATION ---
REPO_USER="mattheweli"
BASE_URL="https://raw.githubusercontent.com/$REPO_USER"

# DIRECTORIES
BIN_DIR="/opt/bin"
NDM_DIR="/opt/etc/ndm/netfilter.d"
INIT_DIR="/opt/etc/init.d"
WEB_ROOT="/opt/var/www"
KEY_FILE="/opt/etc/AbuseIPDB.key"

# EMAIL CONFIGURATION
EMAIL_DIR="/opt/etc/keentool/mail"
EMAIL_CONF="$EMAIL_DIR/email.conf"
EMAIL_PW_FILE="$EMAIL_DIR/emailpw.enc"
EMAIL_ENC_KEY="keentool_internal_secret"

# --- DEPENDENCY LISTS ---
DEPS_CORE="lighttpd bash curl wget-ssl cron openssl-util"
DEPS_VNSTAT="vnstat2 grep awk"
DEPS_PING="sqlite3-cli iputils-ping mtr grep awk"
DEPS_FW="ipset iptables wget-ssl curl sqlite3-cli coreutils-date mtr grep awk sed iprange tcpdump"
DEPS_SMB="bash tar samba4-client coreutils-date"
DEPS_DASH="syslog-ng logrotate"

# --- TOOL DEFINITIONS ---
T_SELF="Keentool Manager|$BIN_DIR/keentool|KeenTool|keentool"
T_DASH="Main Dashboard|$WEB_ROOT/index.html|KeenTool|index.html"
T_VNSTAT="Traffic Manager|$BIN_DIR/traffic_manager.sh|Traffic_manager|Script/traffic_manager.sh"
T_PING="Ping Monitor|$BIN_DIR/pingtool.sh|keenetic-pingtool|scripts/pingtool.sh"
T_SMB="SMB Backup|$BIN_DIR/smb_backup_tool.sh|SMB_Backup_tool|Script/smb_backup_tool.sh"
FW_CORE_LOCAL="$BIN_DIR/update_blocklist.sh"
FW_REPO="keenetic-firewall"

# --- CRON COMMANDS ---
CRON_FILE="/opt/etc/crontab"
CRON_SPOOL_DIR="/opt/var/spool/cron/crontabs"
CRON_SPOOL_FILE="$CRON_SPOOL_DIR/root"

CMD_VNSTAT="root /opt/bin/traffic_manager.sh ppp0 >/opt/var/log/t_manager.log 2>&1"
CMD_PING_BASE="root /opt/bin/pingtool.sh"
CMD_PING_ARGS=">> /opt/var/log/connmon.log 2>&1"
CMD_FW_STAT="root /opt/bin/firewall_stats.sh > /dev/null 2>&1"
CMD_FW_UPD="root /opt/bin/update_blocklist.sh > /dev/null 2>&1"
CMD_FW_VPN="root /opt/bin/vpn_scan.sh > /dev/null 2>&1"
CMD_SMB="/opt/bin/smb_backup_tool.sh -run"
CMD_ABUSE="root /opt/bin/abuse_reporter.sh > /dev/null 2>&1"
CMD_LOGROTATE="root /opt/sbin/logrotate /opt/etc/logrotate.conf"
CMD_SELF_UPD="root /opt/bin/keentool -update >/dev/null 2>&1"

# COLORS
ESC=$(printf '\033')
RESET="${ESC}[0m"
BOLD="${ESC}[1m"
RED="${ESC}[31m"; GREEN="${ESC}[32m"; YELLOW="${ESC}[33m"; BLUE="${ESC}[34m"; CYAN="${ESC}[36m"; MAGENTA="${ESC}[35m"; DIM="${ESC}[2m"

# GLOBAL STATE
UPD_DASH=""; UPD_VNSTAT=""; UPD_PING=""; UPD_FW=""; UPD_SMB=""

# --- UTILS ---
header() { 
    clear
    echo -e "${BOLD}${BLUE}======================================================${RESET}"
    echo -e "${BOLD}${BLUE}   KEENTOOL v0.6.7 ${RESET}${YELLOW}(Beta)${BOLD}${BLUE}     |  Package Manager${RESET}"
    echo -e "${BOLD}${BLUE}======================================================${RESET}"
    echo "" 
}

pause() { 
    echo ""
    read -p "Press [Enter] to return..." fack 
}

get_version() { 
    if [ -f "$1" ]; then
        VER=$(head -n 20 "$1" | grep -oE "v[0-9]+\.[0-9]+\.[0-9]+" | head -n 1)
    fi
    if [ -z "$VER" ]; then
        echo "0.0.0"
    else
        echo "${VER#v}"
    fi
}

get_md5() { 
    if [ -f "$1" ]; then
        md5sum "$1" | awk '{print $1}'
    else
        echo "none"
    fi
}

ver_compare() { 
    if [ "$1" = "$2" ]; then 
        return 0
    fi
    awk -v v1="$1" -v v2="$2" 'BEGIN { 
        split(v1,a,"."); split(v2,b,"."); 
        for(i=1;i<=3;i++) { 
            if(a[i]+0 > b[i]+0) exit 1;
            if(a[i]+0 < b[i]+0) exit 2; 
        } 
        exit 0;
    }'
    return $? 
}

# --- HUMAN READABLE CRON PARSER ---
cron_to_human() {
    # Expects 5 args: min hour dom mon dow
    m=$1; h=$2; dom=$3; mon=$4; dow=$5
    
    # Check for "Every X Minutes" (*/10)
    if echo "$m" | grep -q "\*/"; then
        echo "Every ${m#*/} mins"
        return
    fi
    
    # Check for "Every X Hours" (*/1)
    if echo "$h" | grep -q "\*/"; then
        echo "Every ${h#*/} hours"
        return
    fi
    
    # Format Time (e.g. 4:0 -> 04:00)
    [ ${#m} -eq 1 ] && m="0$m"
    [ ${#h} -eq 1 ] && h="0$h"
    TIME="$h:$m"

    # Weekly (* * * * 0)
    if [ "$dow" != "*" ]; then
        case $dow in
            0|7) D="Sun";; 1) D="Mon";; 2) D="Tue";; 3) D="Wed";; 4) D="Thu";; 5) D="Fri";; 6) D="Sat";; *) D="Day $dow";;
        esac
        echo "Weekly ($D @ $TIME)"
        return
    fi
    
    # Monthly (* * 1 * *)
    if [ "$dom" != "*" ]; then
        echo "Monthly (Day $dom @ $TIME)"
        return
    fi
    
    # Daily
    if [ "$h" != "*" ]; then
        echo "Daily @ $TIME"
        return
    fi
    
    # Fallback
    echo "$m $h $dom $mon $dow"
}

# --- EMAIL HELPERS ---

send_email_notification() {
    # Usage: send_email_notification "Subject" "Body content"
    SUBJECT="$1"
    BODY="$2"
    
    if [ ! -f "$EMAIL_CONF" ] || [ ! -f "$EMAIL_PW_FILE" ]; then
        return 1 # Email not configured
    fi
    
    . "$EMAIL_CONF"
    
    # Decrypt password
    SMTP_PASS_DEC=$(/opt/bin/openssl aes-256-cbc -pbkdf2 -d -in "$EMAIL_PW_FILE" -pass pass:$EMAIL_ENC_KEY 2>/dev/null)
    
    # Construct Email
    MAIL_FILE="/tmp/keentool_mail.txt"
    DATE=$(date -R)
    
    echo "From: \"KeenTool\" <$FROM_ADDRESS>" > "$MAIL_FILE"
    echo "To: <$TO_ADDRESS>" >> "$MAIL_FILE"
    echo "Subject: [KeenTool] $SUBJECT" >> "$MAIL_FILE"
    echo "Date: $DATE" >> "$MAIL_FILE"
    echo "" >> "$MAIL_FILE"
    echo "$BODY" >> "$MAIL_FILE"
    echo "" >> "$MAIL_FILE"
    echo "--" >> "$MAIL_FILE"
    echo "Notification generated by KeenTool Manager" >> "$MAIL_FILE"

    # Send via Curl
    curl --url "$PROTOCOL://$SMTP_SERVER:$SMTP_PORT" \
        --mail-from "$FROM_ADDRESS" \
        --mail-rcpt "$TO_ADDRESS" \
        --upload-file "$MAIL_FILE" \
        --ssl-reqd \
        --user "$SMTP_USER:$SMTP_PASS_DEC" \
        --silent --show-error
    
    RESULT=$?
    rm -f "$MAIL_FILE"
    
    if [ $RESULT -eq 0 ]; then
        return 0
    else
        echo -e "${RED}Email Error (Curl code: $RESULT)${RESET}"
        return 1
    fi
}

configure_email() {
    mkdir -p "$EMAIL_DIR"
    
    header
    echo -e "${BOLD}Email Notifications Setup${RESET}"
    echo -e "Requires: ${CYAN}openssl-util${RESET} (for password encryption)."
    echo ""
    
    if [ -f "$EMAIL_CONF" ]; then
        . "$EMAIL_CONF"
        echo -e "Status: ${GREEN}Configured${RESET}"
        echo "Server: $SMTP_SERVER"
        echo "Recipient: $TO_ADDRESS"
        echo ""
        echo -n "Do you want to re-configure? (y/n): "
        read -r ans
        if [ "$ans" != "y" ] && [ "$ans" != "Y" ]; then return; fi
    fi

    echo ""
    echo "Enter SMTP Details (e.g. Gmail, Outlook):"
    echo "----------------------------------------"
    sleep 1 
    
    echo -n "SMTP Server (e.g. smtp.gmail.com): "
    read -r SMTP_SERVER
    
    echo -n "SMTP Port (e.g. 465 or 587): "
    read -r SMTP_PORT
    
    echo -n "Username (e.g. your@email.com): "
    read -r SMTP_USER
    
    echo -n "Password (App Password recommended): "
    read -r SMTP_PASS
    
    echo -n "Sender Email (From): "
    read -r FROM_ADDRESS
    
    echo -n "Recipient Email (To): "
    read -r TO_ADDRESS
    
    # SMART DETECTION
    DEF_PROTO="smtps"
    if [ "$SMTP_PORT" = "587" ] || [ "$SMTP_PORT" = "25" ]; then
        DEF_PROTO="smtp"
    fi
    
    echo -n "Protocol (smtps or smtp) [$DEF_PROTO]: "
    read -r PROTOCOL
    [ -z "$PROTOCOL" ] && PROTOCOL="$DEF_PROTO"

    # Save Config
    echo "# KeenTool Email Config" > "$EMAIL_CONF"
    echo "SMTP_SERVER=\"$SMTP_SERVER\"" >> "$EMAIL_CONF"
    echo "SMTP_PORT=\"$SMTP_PORT\"" >> "$EMAIL_CONF"
    echo "SMTP_USER=\"$SMTP_USER\"" >> "$EMAIL_CONF"
    echo "FROM_ADDRESS=\"$FROM_ADDRESS\"" >> "$EMAIL_CONF"
    echo "TO_ADDRESS=\"$TO_ADDRESS\"" >> "$EMAIL_CONF"
    echo "PROTOCOL=\"$PROTOCOL\"" >> "$EMAIL_CONF"

    # Encrypt Password
    echo -n "$SMTP_PASS" | /opt/bin/openssl aes-256-cbc -pbkdf2 -out "$EMAIL_PW_FILE" -pass pass:$EMAIL_ENC_KEY
    
    chmod 600 "$EMAIL_CONF"
    chmod 600 "$EMAIL_PW_FILE"

    echo ""
    echo -e "${GREEN}Configuration saved.${RESET}"
    
    echo -n "Send a test email now? (y/n): "
    read -r test_ans
    if [ "$test_ans" = "y" ] || [ "$test_ans" = "Y" ]; then
        echo -n "Sending..."
        if send_email_notification "Test Email" "This is a test notification from your Keenetic Router."; then
            echo -e " ${GREEN}Success!${RESET}"
        else
            echo -e " ${RED}Failed.${RESET}"
        fi
        pause
    fi
}

# --- HELPERS ---
apply_perms() {
    FILE=$1
    sed -i 's/\r$//' "$FILE"
    if [ "${FILE##*.}" = "sh" ] || [ "$(basename "$FILE")" = "firewall_monitor" ] || [ "$(basename "$FILE")" = "keentool" ]; then
        chmod +x "$FILE"
    elif [ "${FILE##*.}" = "html" ] || [ "${FILE##*.}" = "conf" ]; then
        chmod 644 "$FILE"
    fi
}

run_protected() {
    # Fixes Ctrl+C killing the parent script
    trap ':' INT
    $1
    trap - INT
}

# --- HEADLESS SELF-UPDATE (CLI) ---
perform_self_update_headless() {
    IFS='|' read -r N P R F <<EOF
$T_SELF
EOF
    TMP_FILE="/tmp/keentool_bg.tmp"
    curl -s -L "$BASE_URL/$R/main/$F" -o "$TMP_FILE"
    
    if [ ! -s "$TMP_FILE" ]; then 
        rm -f "$TMP_FILE"
        exit 1
    fi
    
    sed -i 's/\r$//' "$TMP_FILE"
    L_VER=$(get_version "$P")
    R_VER=$(get_version "$TMP_FILE")
    
    ver_compare "$R_VER" "$L_VER"
    RES=$?
    
    # Update if Remote > Local (1) or Hash diff (0)
    if [ $RES -eq 1 ] || { [ $RES -eq 0 ] && [ "$(get_md5 "$P")" != "$(get_md5 "$TMP_FILE")" ]; }; then
        mv "$TMP_FILE" "$P"
        chmod +x "$P"
        MSG="KeenTool updated successfully from v$L_VER to v$R_VER."
        logger -t "KeenTool" "$MSG"
        
        # EMAIL NOTIFICATION ON SUCCESS
        send_email_notification "Auto-Update Successful" "$MSG"
    else
        rm -f "$TMP_FILE"
    fi
    exit 0
}

# --- ARGUMENT HANDLING ---
case "$1" in
    -update|--update)
        perform_self_update_headless
        ;;
esac

# --- CONFIGURATORS ---

configure_logging_modules() {
    # Defaults
    EN_VPN="yes"
    EN_SCRIPTS="yes"
    EN_DNS="yes"
    EN_WIFI="yes"
    EN_DHCP="yes"
    EN_PROXY="yes"
    
    CONF="/opt/etc/syslog-ng.conf"
    
    # Detect current state (Fixed grep logic: checks active log lines, not filters)
    if [ -f "$CONF" ]; then
        if grep -q "filter(f_vpn); destination(d_vpn);" "$CONF"; then EN_VPN="yes"; else EN_VPN="no"; fi
        if grep -q "filter(f_scripts); destination(d_scripts);" "$CONF"; then EN_SCRIPTS="yes"; else EN_SCRIPTS="no"; fi
        if grep -q "filter(f_dns); destination(d_dns);" "$CONF"; then EN_DNS="yes"; else EN_DNS="no"; fi
        if grep -q "filter(f_wifi); destination(d_wifi);" "$CONF"; then EN_WIFI="yes"; else EN_WIFI="no"; fi
        if grep -q "filter(f_dhcp); destination(d_dhcp);" "$CONF"; then EN_DHCP="yes"; else EN_DHCP="no"; fi
        if grep -q "filter(f_proxy); destination(d_proxy);" "$CONF"; then EN_PROXY="yes"; else EN_PROXY="no"; fi
    fi

    while true; do
        header
        echo -e "${BOLD}Modular Logging Configuration${RESET}"
        
        # Color Logic
        if [ "$EN_VPN" = "yes" ]; then c_vpn="${GREEN}ON${RESET}"; else c_vpn="${RED}OFF${RESET}"; fi
        if [ "$EN_SCRIPTS" = "yes" ]; then c_scr="${GREEN}ON${RESET}"; else c_scr="${RED}OFF${RESET}"; fi
        if [ "$EN_DNS" = "yes" ]; then c_dns="${GREEN}ON${RESET}"; else c_dns="${RED}OFF${RESET}"; fi
        if [ "$EN_WIFI" = "yes" ]; then c_wif="${GREEN}ON${RESET}"; else c_wif="${RED}OFF${RESET}"; fi
        if [ "$EN_DHCP" = "yes" ]; then c_dhc="${GREEN}ON${RESET}"; else c_dhc="${RED}OFF${RESET}"; fi
        if [ "$EN_PROXY" = "yes" ]; then c_prx="${GREEN}ON${RESET}"; else c_prx="${RED}OFF${RESET}"; fi
        
        echo -e " 1. VPN Events (OpenVPN/WireGuard)    [$c_vpn]"
        echo -e " 2. Keentool Scripts (Traffic/Ping)   [$c_scr]"
        echo -e " 3. DNS Proxy Errors (Timeout Spam)   [$c_dns]"
        echo -e " 4. WiFi Monitor (Mediatek Spam)      [$c_wif]"
        echo -e " 5. DHCP Events (ndhcps)              [$c_dhc]"
        echo -e " 6. Reverse Proxy (Nginx SSL Errors)  [$c_prx]"
        echo ""
        echo -e " ${BOLD}a. APPLY CHANGES & RESTART SERVICES${RESET}"
        echo " 0. Cancel / Back"
        echo ""
        echo -n "Select: "
        read -r opt
        
        case $opt in
            1) if [ "$EN_VPN" = "yes" ]; then EN_VPN="no"; else EN_VPN="yes"; fi ;;
            2) if [ "$EN_SCRIPTS" = "yes" ]; then EN_SCRIPTS="no"; else EN_SCRIPTS="yes"; fi ;;
            3) if [ "$EN_DNS" = "yes" ]; then EN_DNS="no"; else EN_DNS="yes"; fi ;;
            4) if [ "$EN_WIFI" = "yes" ]; then EN_WIFI="no"; else EN_WIFI="yes"; fi ;;
            5) if [ "$EN_DHCP" = "yes" ]; then EN_DHCP="no"; else EN_DHCP="yes"; fi ;;
            6) if [ "$EN_PROXY" = "yes" ]; then EN_PROXY="no"; else EN_PROXY="yes"; fi ;;
            a)
                echo ""
                echo -e "${CYAN}Applying Configuration...${RESET}"
                
                # 1. SETUP SYMLINKS
                mkdir -p "$WEB_ROOT"
                LOG_LIST="vpn keentool dns_proxy wifi_monitor ndhcps nginx_proxy"
                
                for L in $LOG_LIST; do
                    if [ ! -f "/opt/var/log/${L}.log" ]; then
                        touch "/opt/var/log/${L}.log"
                    fi
                    chmod 644 "/opt/var/log/${L}.log"
                    
                    if [ ! -L "$WEB_ROOT/${L}.log" ]; then
                        ln -sf "/opt/var/log/${L}.log" "$WEB_ROOT/${L}.log"
                    fi
                done
                
                if [ ! -L "$WEB_ROOT/messages.log" ]; then 
                    ln -sf /opt/var/log/messages "$WEB_ROOT/messages.log"
                fi

                # 2. GENERATE SYSLOG-NG
                cat > /opt/etc/syslog-ng.conf <<EOF
@version: 4.7
@include "scl.conf"

options { 
    chain_hostnames(no); 
    create_dirs(yes); 
    keep_hostname(yes); 
    use_fqdn(no); 
    log_msg_size(16384); 
    log_fifo_size(256); 
    stats(freq(21600)); 
    dns-cache(no); 
};

source s_local { internal(); unix-dgram("/dev/log"); };
source s_network { udp(ip("0.0.0.0") port(514)); };

# FILTERS
filter f_dns { program("https-dns-proxy"); };
filter f_wifi { message("Network::Interface::Mtk::WifiMonitor") or message("WifiMonitor"); };
filter f_dhcp { program("ndhcps"); };
filter f_vpn { program("OpenVPN.*") or program("wireguard") or message("WireGuard"); };
filter f_scripts { 
    program("traffic_manager") or program("pingtool") or 
    program("Firewall_Stats") or program("firewall_stats") or 
    program("Firewall_Update") or program("firewall_update") or 
    program("Abuse_Reporter") or program("abuse_reporter") or 
    program("VPN_Scanner") or program("vpn_scan") or 
    program("blocklist_loader") or program("update_blocklist") or 
    message("traffic_manager") or message("pingtool") or 
    message("Firewall_Stats") or message("Keentool");
};
filter f_proxy { program("nginx") or message("nginx:"); };

# CLEAN FILTER (EXCLUDES ENABLED MODULES)
filter f_clean {
    not filter(f_dns) and 
    not filter(f_wifi) and 
    not filter(f_dhcp) and 
    not filter(f_vpn) and 
    not filter(f_scripts) and 
    not filter(f_proxy);
};

# DESTINATIONS
destination d_messages { file("/opt/var/log/messages"); };
destination d_dns      { file("/opt/var/log/dns_proxy.log"); };
destination d_wifi     { file("/opt/var/log/wifi_monitor.log"); };
destination d_dhcp     { file("/opt/var/log/ndhcps.log"); };
destination d_vpn      { file("/opt/var/log/vpn.log"); };
destination d_scripts  { file("/opt/var/log/keentool.log"); };
destination d_proxy    { file("/opt/var/log/nginx_proxy.log"); };

# LOG PATHS (Clean)
log { source(s_local); source(s_network); filter(f_clean); destination(d_messages); };
log { source(s_local); source(s_network); filter(f_clean); destination(d_nas); };
EOF
                # Append enabled logs
                if [ "$EN_DNS" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_dns); destination(d_dns); };' >> /opt/etc/syslog-ng.conf
                fi
                
                if [ "$EN_WIFI" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_wifi); destination(d_wifi); };' >> /opt/etc/syslog-ng.conf
                fi
                
                if [ "$EN_DHCP" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_dhcp); destination(d_dhcp); };' >> /opt/etc/syslog-ng.conf
                fi
                
                if [ "$EN_VPN" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_vpn); destination(d_vpn); };' >> /opt/etc/syslog-ng.conf
                fi
                
                if [ "$EN_SCRIPTS" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_scripts); destination(d_scripts); };' >> /opt/etc/syslog-ng.conf
                fi
                
                if [ "$EN_PROXY" = "yes" ]; then 
                    echo 'log { source(s_local); source(s_network); filter(f_proxy); destination(d_proxy); };' >> /opt/etc/syslog-ng.conf
                fi

                # 3. GENERATE LOGROTATE
                cat > /opt/etc/logrotate.d/syslog-ng <<EOF
/opt/var/log/messages { 
    rotate 4 
    size 5M 
    missingok 
    notifempty 
    compress 
    postrotate 
        /opt/etc/init.d/S01syslog-ng restart > /dev/null 2>&1 
    endscript 
}
EOF
                
                SECLOGS=""
                [ "$EN_DNS" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/dns_proxy.log"
                [ "$EN_WIFI" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/wifi_monitor.log"
                [ "$EN_DHCP" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/ndhcps.log"
                [ "$EN_VPN" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/vpn.log"
                [ "$EN_SCRIPTS" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/keentool.log"
                [ "$EN_PROXY" = "yes" ] && SECLOGS="$SECLOGS /opt/var/log/nginx_proxy.log"
                
                if [ -n "$SECLOGS" ]; then
                    echo "$SECLOGS {" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    monthly" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    rotate 2" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    size 5M" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    missingok" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    notifempty" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    compress" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    postrotate" >> /opt/etc/logrotate.d/syslog-ng
                    echo "        /opt/etc/init.d/S01syslog-ng restart > /dev/null 2>&1" >> /opt/etc/logrotate.d/syslog-ng
                    echo "    endscript" >> /opt/etc/logrotate.d/syslog-ng
                    echo "}" >> /opt/etc/logrotate.d/syslog-ng
                fi

                # 4. PATCH INDEX.HTML (JS CONFIG)
                if [ -f "$WEB_ROOT/index.html" ]; then
                    echo " -> Patching Dashboard HTML..."
                    JS_CONFIG="const logConfig = ["
                    JS_CONFIG="$JS_CONFIG { id: 'main', file: 'messages.log', label: 'ðŸ“œ SYSTEM LOG', primary: true },"
                    
                    if [ "$EN_VPN" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'vpn', file: 'vpn.log', label: 'ðŸ›¡ï¸ VPN Events', primary: false },"
                    fi
                    if [ "$EN_PROXY" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'proxy', file: 'nginx_proxy.log', label: 'ðŸŒ Reverse Proxy (Nginx)', primary: false },"
                    fi
                    if [ "$EN_SCRIPTS" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'scripts', file: 'keentool.log', label: 'ðŸ¤– Keentool Scripts', primary: false },"
                    fi
                    if [ "$EN_DNS" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'dns', file: 'dns_proxy.log', label: 'ðŸŒ DNS Proxy Errors', primary: false },"
                    fi
                    if [ "$EN_WIFI" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'wifi', file: 'wifi_monitor.log', label: 'ðŸ“¶ WiFi Monitor Spam', primary: false },"
                    fi
                    if [ "$EN_DHCP" = "yes" ]; then
                        JS_CONFIG="$JS_CONFIG { id: 'dhcp', file: 'ndhcps.log', label: 'ðŸ”Œ DHCP Events', primary: false },"
                    fi
                    
                    # Remove trailing comma
                    JS_CONFIG="${JS_CONFIG%,} ];"
                    # Use sed with a temporary file approach to be safe with slashes/newlines
                    sed -i '/const logConfig = \[/,/\];/c\'"$JS_CONFIG" "$WEB_ROOT/index.html"
                fi

                # 5. RESTART
                echo " -> Restarting Syslog-ng..."
                /opt/etc/init.d/S01syslog-ng restart >/dev/null 2>&1
                
                echo -e "${GREEN}Done. Configuration applied.${RESET}"
                sleep 1
                return
                ;;
            0) return ;;
        esac
    done
}

configure_traffic() {
    # 1. Parse current Interface from internal variable (CMD_VNSTAT)
    CUR_IFACE=$(echo "$CMD_VNSTAT" | grep -o 'traffic_manager.sh [^ ]*' | cut -d' ' -f2)
    [ -z "$CUR_IFACE" ] && CUR_IFACE="ppp0"

    while true; do
        header
        echo -e "${BOLD}Traffic Manager Configuration${RESET}"
        echo ""
        echo -e " Current Dashboard Target: ${CYAN}${CUR_IFACE}${RESET}"
        echo ""
        
        # Get VNStat DB list
        echo -e "${BOLD}Available Interfaces (VNStat DB):${RESET}"
        if command -v vnstat >/dev/null 2>&1; then
            vnstat --iflist 2>/dev/null | awk '{print "  - " $0}'
        else
            echo "  (VNStat not found)"
        fi
        
        echo ""
        echo " 1. Set Dashboard Interface (Updates Cron)"
        echo " 2. Add New Interface to DB (vnstat --add)"
        echo " 3. Remove Interface from DB (vnstat --remove)"
        echo " 0. Back"
        echo ""
        echo -n "Select option: "; read -r opt
        
        case $opt in
            1) 
                echo -n "Enter Interface Name (e.g. ppp0, usb0, eth3): "
                read -r NEW_IF
                if [ -n "$NEW_IF" ]; then
                    sed -i "s|traffic_manager.sh [a-zA-Z0-9_.]*|traffic_manager.sh $NEW_IF|" "$0"
                    CUR_IFACE="$NEW_IF"
                    NEW_CMD="root /opt/bin/traffic_manager.sh $NEW_IF >/opt/var/log/t_manager.log 2>&1"
                    if grep -q "traffic_manager.sh" "$CRON_FILE"; then
                        echo " -> Updating Crontab..."
                        grep -v "traffic_manager.sh" "$CRON_FILE" > "$CRON_FILE.tmp" && mv "$CRON_FILE.tmp" "$CRON_FILE"
                        echo "*/10 * * * * $NEW_CMD" >> "$CRON_FILE"
                        sanitize_and_reload_cron
                    fi
                    echo -e " -> ${GREEN}Target set to $NEW_IF.${RESET}"
                    sleep 1
                fi
                ;;
            2)
                echo -n "Enter Interface to ADD (e.g. usb0): "
                read -r ADD_IF
                if [ -n "$ADD_IF" ]; then
                    echo " -> Adding $ADD_IF..."
                    vnstat --add -i "$ADD_IF"
                    /opt/etc/init.d/S32vnstat2 restart
                    echo -e " -> ${GREEN}Done. Please allow ~10m for data collection.${RESET}"
                    pause
                fi
                ;;
            3)
                echo -n "Enter Interface to REMOVE (e.g. eth0): "
                read -r DEL_IF
                if [ -n "$DEL_IF" ]; then
                    echo " -> Removing $DEL_IF..."
                    vnstat --remove -i "$DEL_IF" --force
                    /opt/etc/init.d/S32vnstat2 restart
                    echo -e " -> ${RED}Removed.${RESET}"
                    pause
                fi
                ;;
            0) return ;;
        esac
    done
}

configure_pingtool() {
    P="/opt/bin/pingtool.sh"
    if [ ! -f "$P" ]; then 
        echo -e "${RED}Error: Ping Monitor is not installed.${RESET}"
        pause
        return
    fi
    
    NEED_REFRESH=0
    
    while true; do
        header
        echo -e "${BOLD}Ping Monitor Configuration${RESET}"
        
        CUR_V4=$(grep '^PING_TARGET="' "$P" | cut -d'"' -f2)
        CUR_V6=$(grep '^PING_TARGET_V6="' "$P" | cut -d'"' -f2)
        CUR_MODE=$(grep '^ENABLE_IPV6="' "$P" | cut -d'"' -f2)
        CUR_DUR=$(grep '^PING_DURATION=' "$P" | cut -d'=' -f2)
        CUR_LAT=$(grep '^TRIGGER_LATENCY=' "$P" | cut -d'=' -f2)
        CUR_RET=$(grep '^RETENTION_DAYS=' "$P" | cut -d'=' -f2)
        
        if [ "$CUR_MODE" = "true" ]; then LBL_MODE="${GREEN}Enabled${RESET}"; else LBL_MODE="${RED}Disabled${RESET}"; fi
        
        echo ""
        echo -e " ${BOLD}Targets:${RESET}"
        echo -e " 1. Set IPv4 Target      [Current: ${CYAN}$CUR_V4${RESET}]"
        echo -e " 2. Set IPv6 Target      [Current: ${CYAN}$CUR_V6${RESET}]"
        echo -e " 3. Toggle IPv6 Mode     [$LBL_MODE]"
        echo ""
        echo -e " ${BOLD}Parameters:${RESET}"
        echo -e " 4. Ping Duration        [Current: ${CYAN}${CUR_DUR}s${RESET}]"
        echo -e " 5. Trigger Latency      [Current: ${CYAN}${CUR_LAT}ms${RESET}]"
        echo -e " 6. DB Retention Days    [Current: ${CYAN}${CUR_RET} days${RESET}]"
        echo ""
        echo " 0. Back"
        echo ""
        echo -n "Select setting to change: "; read -r opt
        
        case $opt in
            1) echo -n "Enter new IPv4 Target (e.g., 1.1.1.1): "; read -r NEW_VAL
               if [ -n "$NEW_VAL" ]; then
                   sed -i 's/^PING_TARGET=".*"/PING_TARGET="'$NEW_VAL'"/' "$P"
                   echo -e " -> ${GREEN}Updated.${RESET}"; NEED_REFRESH=1
               fi ;;
            2) echo -n "Enter new IPv6 Target: "; read -r NEW_VAL
               if [ -n "$NEW_VAL" ]; then
                   sed -i 's/^PING_TARGET_V6=".*"/PING_TARGET_V6="'$NEW_VAL'"/' "$P"
                   echo -e " -> ${GREEN}Updated.${RESET}"; NEED_REFRESH=1
               fi ;;
            3) if [ "$CUR_MODE" = "true" ]; then NEW_MODE="false"; else NEW_MODE="true"; fi
               sed -i 's/^ENABLE_IPV6=".*"/ENABLE_IPV6="'$NEW_MODE'"/' "$P"
               echo -e " -> Mode switched to: $NEW_MODE"; NEED_REFRESH=1 ;;
            4) echo -n "Enter Duration (seconds, e.g. 30): "; read -r NEW_VAL
               if [ -n "$NEW_VAL" ]; then
                   sed -i "s/^PING_DURATION=.*/PING_DURATION=$NEW_VAL/" "$P"
                   echo -e " -> ${GREEN}Updated.${RESET}"; NEED_REFRESH=1
               fi ;;
            5) echo -n "Enter Latency Threshold (ms, e.g. 50): "; read -r NEW_VAL
               if [ -n "$NEW_VAL" ]; then
                   sed -i "s/^TRIGGER_LATENCY=.*/TRIGGER_LATENCY=$NEW_VAL/" "$P"
                   echo -e " -> ${GREEN}Updated.${RESET}"; NEED_REFRESH=1
               fi ;;
            6) echo -n "Enter DB Retention (days, e.g. 45): "; read -r NEW_VAL
               if [ -n "$NEW_VAL" ]; then
                   sed -i "s/^RETENTION_DAYS=.*/RETENTION_DAYS=$NEW_VAL/" "$P"
                   echo -e " -> ${GREEN}Updated.${RESET}"; NEED_REFRESH=1
               fi ;;
            0) 
               if [ $NEED_REFRESH -eq 1 ]; then
                   echo ""
                   echo -e "${YELLOW}You made changes.${RESET}"
                   echo -n " -> Run Pingtool now to update Dashboard data? (Takes ~${CUR_DUR}s) (y/n): "
                   read -r refresh
                   if [ "$refresh" = "y" ] || [ "$refresh" = "Y" ]; then
                       echo "Running Pingtool... Please wait..."
                       run_protected "$P"
                       echo -e "${GREEN}Done. Dashboard updated.${RESET}"
                       sleep 1
                   fi
               fi
               return ;;
        esac
        sleep 0.5
    done
}

# --- SELF UPDATE (INTERACTIVE) ---
action_self_update() {
    header; echo -e "${BOLD}Checking Keentool status...${RESET}"
    IFS='|' read -r N P R F <<EOF
$T_SELF
EOF
    TMP_FILE="/tmp/keentool.tmp"
    echo -n " -> Contacting GitHub ($R)... "; curl -s -L "$BASE_URL/$R/main/$F" -o "$TMP_FILE"
    
    if [ ! -s "$TMP_FILE" ]; then 
        echo -e "${RED}Failed.${RESET}"; rm -f "$TMP_FILE"; pause; return
    fi
    
    sed -i 's/\r$//' "$TMP_FILE"
    L_VER=$(get_version "$P"); R_VER=$(get_version "$TMP_FILE"); ver_compare "$R_VER" "$L_VER"; RES=$?
    
    echo -e " ${GREEN}OK${RESET}"; echo ""
    if [ $RES -eq 1 ]; then
        echo -e "${MAGENTA}Update: v$L_VER -> v$R_VER${RESET}"
        echo -n " -> Apply & Restart? (y/n): "; read -r ans
        if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then 
            mv "$TMP_FILE" "$P"; apply_perms "$P"
            echo -e "${GREEN}Updated.${RESET}"; sleep 1; exec "$P"
        else rm -f "$TMP_FILE"; pause; fi
    elif [ $RES -eq 2 ]; then
        echo -e "${YELLOW}Local is Newer (Dev).${RESET}"; rm -f "$TMP_FILE"; pause
    else
        if [ "$(get_md5 "$P")" != "$(get_md5 "$TMP_FILE")" ]; then
            echo -e "${CYAN}MD5 Differs.${RESET}"
            echo -n " -> Force Reinstall? (y/n): "; read -r ans
            if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then 
                mv "$TMP_FILE" "$P"; apply_perms "$P"
                echo "Reinstalling..."; sleep 1; exec "$P"
            else rm -f "$TMP_FILE"; pause; fi
        else echo -e "${GREEN}Up to date.${RESET}"; rm -f "$TMP_FILE"; pause; fi
    fi
}

# --- SYSTEM SETUP ---
setup_system() {
    header
    echo -e "${BOLD}System Pre-Flight Check${RESET}"; echo "---------------------------------------"
    echo -e "Checking Core Packages: ${DIM}$DEPS_CORE${RESET}"; check_and_install_deps "$DEPS_CORE"
    echo -e "Checking Web Environment..."
    check_webserver_config "force"
    echo -n "Checking Cron Service... "
    if pidof cron >/dev/null; then echo -e "${GREEN}Running${RESET}"; else
        echo -e "${RED}Stopped${RESET}"; echo -n " -> Start Cron? (y/n): "; read -r ans
        if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then /opt/etc/init.d/S10cron start; echo -e "    ${GREEN}Started.${RESET}"; fi
    fi
    sanitize_and_reload_cron
    echo ""; echo -e "${BOLD}System Ready.${RESET}"; pause
}

# --- GLOBAL SCAN ---
perform_global_scan() {
    echo -e "${BOLD}Checking for updates...${RESET}"
    check_tool_status() {
        local VNAME=$1; local LPATH=$2; local REPO=$3; local RFILE=$4
        echo -n "."
        if [ -f "$LPATH" ]; then
            local L_VER=$(get_version "$LPATH"); local TMP="/tmp/check_${RFILE##*/}.tmp"
            curl -s -L "$BASE_URL/$REPO/main/$RFILE" -o "$TMP"
            if [ -s "$TMP" ]; then
                sed -i 's/\r$//' "$TMP"
                local R_VER=$(get_version "$TMP"); ver_compare "$R_VER" "$L_VER"; local RES=$?
                if [ $RES -eq 1 ]; then eval "${VNAME}=' -> ${MAGENTA}v${R_VER}${RESET}'"
                elif [ $RES -eq 0 ] && [ "$(get_md5 "$LPATH")" != "$(get_md5 "$TMP")" ]; then eval "${VNAME}=' -> ${CYAN}Changed${RESET}'"
                else eval "${VNAME}=''"; fi
                rm -f "$TMP"
            else eval "${VNAME}=''"; fi
        else eval "${VNAME}=''"; fi
    }
    
    IFS='|' read -r N P R F <<EOF
$T_DASH
EOF
    check_tool_status "UPD_DASH" "$P" "$R" "$F"

    IFS='|' read -r N P R F <<EOF
$T_VNSTAT
EOF
    check_tool_status "UPD_VNSTAT" "$P" "$R" "$F"
    
    IFS='|' read -r N P R F <<EOF
$T_PING
EOF
    check_tool_status "UPD_PING" "$P" "$R" "$F"
    
    check_tool_status "UPD_FW" "$FW_CORE_LOCAL" "$FW_REPO" "scripts/update_blocklist.sh"
    
    if [ -z "$UPD_FW" ] && [ -f "$FW_CORE_LOCAL" ]; then
        FW_SUBS="$BIN_DIR/firewall_manager.sh|scripts/firewall_manager.sh
$BIN_DIR/firewall_monitor|scripts/firewall_monitor
$BIN_DIR/firewall_stats.sh|scripts/firewall_stats.sh
$BIN_DIR/vpn_scan.sh|scripts/vpn_scan.sh
$BIN_DIR/abuse_reporter.sh|scripts/abuse_reporter.sh
$NDM_DIR/100-firewall.sh|scripts/100-firewall.sh
$INIT_DIR/S00ipset-load|scripts/S00ipset-load"
        IFS=$'\n'; for ROW in $FW_SUBS; do
            local SUB_L=$(echo "$ROW" | cut -d'|' -f1); local SUB_R=$(echo "$ROW" | cut -d'|' -f2)
            if [ -f "$SUB_L" ]; then
                echo -n "."; local SL_VER=$(get_version "$SUB_L"); local STMP="/tmp/chk_fw_sub.tmp"
                curl -s -L "$BASE_URL/$FW_REPO/main/$SUB_R" -o "$STMP"
                if [ -s "$STMP" ]; then
                    sed -i 's/\r$//' "$STMP"
                    local SR_VER=$(get_version "$STMP"); ver_compare "$SR_VER" "$SL_VER"; local RES=$?
                    if [ $RES -eq 1 ]; then UPD_FW=" -> ${MAGENTA}Patch${RESET}"; rm -f "$STMP"; break; fi
                    if [ $RES -eq 0 ] && [ "$(get_md5 "$SUB_L")" != "$(get_md5 "$STMP")" ]; then UPD_FW=" -> ${CYAN}Patch${RESET}"; rm -f "$STMP"; break; fi
                fi
                rm -f "$STMP"
            fi
        done; unset IFS
    fi
    
    IFS='|' read -r N P R F <<EOF
$T_SMB
EOF
    check_tool_status "UPD_SMB" "$P" "$R" "$F"
    echo " Done."; sleep 0.5
}

# --- DEPENDENCY & INSTALL ---
check_and_install_deps() {
    PKG_LIST="$1"; MISSING=""
    for PKG in $PKG_LIST; do 
        if opkg list-installed | grep -q "^$PKG"; then continue; fi
        if command -v "$PKG" >/dev/null 2>&1; then continue; fi
        MISSING="$MISSING $PKG"
    done
    if [ -n "$MISSING" ]; then
        echo -e " -> ${YELLOW}Missing:${RESET} $MISSING"; echo -n " -> Install? (y/n): "; read -r ans
        if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
            echo "    Installing..."; opkg update >/dev/null 2>&1; opkg install $MISSING
            if echo "$PKG_LIST" | grep -q "lighttpd"; then check_webserver_config "check"; fi
            if echo "$PKG_LIST" | grep -q "vnstat2"; then check_vnstat_config; fi
        else return 1; fi
    else echo -e " -> ${GREEN}OK${RESET}"; fi
    if echo "$PKG_LIST" | grep -q "lighttpd"; then check_webserver_config "check"; fi
    if echo "$PKG_LIST" | grep -q "vnstat2"; then check_vnstat_config; fi
    return 0
}

check_vnstat_config() {
    CONF="/opt/etc/vnstat.conf"
    if [ ! -f "$CONF" ]; then
        echo -n " -> ${YELLOW}Configure vnStat (Download Config)? (y/n): ${RESET}"; read -r ans
        if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
            echo -n "    Downloading vnstat.conf from KeenTool repo... "
            curl -s -L "$BASE_URL/KeenTool/main/vnstat.conf" -o "$CONF"
            if [ -s "$CONF" ]; then
                echo -e "${GREEN}OK${RESET}"; chmod 644 "$CONF"
            else
                echo -e "${RED}Failed (Using Minimal Fallback)${RESET}"
                echo 'Interface ""' > "$CONF"; echo 'DatabaseDir "/opt/var/lib/vnstat"' >> "$CONF"
            fi
            if [ -x /opt/etc/init.d/S32vnstat2 ]; then /opt/etc/init.d/S32vnstat2 restart >/dev/null 2>&1; fi
        fi
    fi
}

check_webserver_config() {
    MODE=$1; CONF="/opt/etc/lighttpd/lighttpd.conf"
    if [ ! -d "$WEB_ROOT" ]; then mkdir -p "$WEB_ROOT"; fi
    if [ ! -f "$WEB_ROOT/index.html" ] || [ "$MODE" = "force" ]; then
         echo -n " -> Downloading Dashboard to $WEB_ROOT... "
         curl -s -L "$BASE_URL/KeenTool/main/index.html" -o "$WEB_ROOT/index.html"
         [ -s "$WEB_ROOT/index.html" ] && chmod 644 "$WEB_ROOT/index.html"
    fi
    if [ -f "$CONF" ]; then
        if grep -q "server.port.*=.*81" "$CONF" && [ "$MODE" != "force" ]; then return 0; fi
    fi
    if [ "$MODE" != "force" ]; then
        echo -n " -> ${YELLOW}Configure Lighttpd (Port 81)? (y/n): ${RESET}"; read -r ans
        [ "$ans" != "y" ] && [ "$ans" != "Y" ] && return 0
    fi
    mkdir -p /opt/etc/lighttpd
    cat > "$CONF" <<EOF
var.log_root    = "/opt/var/log/lighttpd/"
var.server_root = "/opt/var/www/"
var.state_dir   = "/opt/var/run/"
var.home_dir    = "/opt/var/lib/lighttpd/"
var.conf_dir    = "/opt/etc/lighttpd"
var.vhosts_dir  = server_root + "/vhosts"
var.cache_dir   = "/opt/var/cache/lighttpd"
var.socket_dir  = home_dir + "/sockets"
server.document-root = server_root
server.upload-dirs = ( "/opt/tmp" )
server.errorlog = log_root + "error.log"
server.pid-file = state_dir + "lighttpd.pid"
server.port = 81
index-file.names = ( "index.php", "index.html", "index.htm" )
static-file.exclude-extensions = ( ".php", ".pl", ".fcgi" )
include "/opt/etc/lighttpd/mime.conf"
include "/opt/etc/lighttpd/conf.d/*.conf"
EOF
    [ -x /opt/etc/init.d/S80lighttpd ] && { /opt/etc/init.d/S80lighttpd restart >/dev/null 2>&1; echo -e "    ${GREEN}Configured & Restarted.${RESET}"; }
}

configure_dashboard_extras() {
    # 1. Always link main message log
    if [ ! -L "$WEB_ROOT/messages.log" ]; then
        echo -n " -> Linking System Log to Web Root... "
        ln -sf /opt/var/log/messages "$WEB_ROOT/messages.log"
        echo -e "${GREEN}Done.${RESET}"
    fi

    # 2. Setup Services
    if [ -x /opt/etc/init.d/S01syslog-ng ]; then
        if ! pidof syslog-ng >/dev/null; then /opt/etc/init.d/S01syslog-ng start; fi
    fi
    if [ -f /opt/etc/logrotate.conf ]; then
        chmod 644 /opt/etc/logrotate.conf
        [ -d /opt/etc/logrotate.d ] && chmod 755 /opt/etc/logrotate.d
        if ! grep -q "logrotate" "$CRON_FILE"; then
            echo "0 4 * * * root /opt/sbin/logrotate /opt/etc/logrotate.conf" >> "$CRON_FILE"
            sanitize_and_reload_cron
        fi
    fi

    # 3. Prompt for Modules
    configure_logging_modules
}

# --- GENERIC INSTALL/UPDATE HELPERS ---
install_file() {
    REPO=$1; RFILE=$2; LPATH=$3; DIR=$(dirname "$LPATH"); mkdir -p "$DIR"
    echo -n " -> Downloading ${CYAN}${RFILE##*/}${RESET}... "; curl -s -L "$BASE_URL/$REPO/main/$RFILE" -o "$LPATH"
    if [ -s "$LPATH" ]; then 
        apply_perms "$LPATH"
        echo -e "${GREEN}OK${RESET}"; return 0
    else 
        echo -e "${RED}Failed${RESET}"; rm -f "$LPATH"; return 1
    fi
}

smart_process() {
    NAME=$1; LPATH=$2; REPO=$3; RFILE=$4
    if [ ! -f "$LPATH" ]; then
        echo -e "${BOLD}Installing: $NAME${RESET}"; echo -n " -> Confirm? (y/n): "; read -r ans
        [ "$ans" = "y" ] || [ "$ans" = "Y" ] && install_file "$REPO" "$RFILE" "$LPATH"
        return
    fi
    echo -n "Checking $NAME... "; TMP_FILE="/tmp/${RFILE##*/}.tmp"; curl -s -L "$BASE_URL/$REPO/main/$RFILE" -o "$TMP_FILE"
    if [ ! -s "$TMP_FILE" ]; then echo -e "${RED}Net Error${RESET}"; rm -f "$TMP_FILE"; return; fi
    sed -i 's/\r$//' "$TMP_FILE"
    L_VER=$(get_version "$LPATH"); R_VER=$(get_version "$TMP_FILE"); ver_compare "$R_VER" "$L_VER"; RES=$?
    UPDATE_NEEDED=0; MSG=""
    if [ $RES -eq 1 ]; then UPDATE_NEEDED=1; MSG="${MAGENTA}Update: v$L_VER -> v$R_VER${RESET}"
    elif [ $RES -eq 0 ] && [ "$(get_md5 "$LPATH")" != "$(get_md5 "$TMP_FILE")" ]; then UPDATE_NEEDED=1; MSG="${CYAN}Content Changed (Patch)${RESET}"; fi
    if [ $UPDATE_NEEDED -eq 1 ]; then
        echo -e "$MSG"; echo -n "    Apply? (y/n): "; read -r ans
        [ "$ans" = "y" ] && { 
            mv "$TMP_FILE" "$LPATH"
            apply_perms "$LPATH"
            echo -e "    ${GREEN}Updated.${RESET}"
        } || rm -f "$TMP_FILE"
    else
        rm -f "$TMP_FILE"; echo -e "${GREEN}Up to date.${RESET}"
    fi
}

# --- CRON MANAGEMENT ---
sanitize_and_reload_cron() {
    [ ! -f "$CRON_FILE" ] && touch "$CRON_FILE"
    awk 'length($0) == 0 || !seen[$0]++' "$CRON_FILE" > "$CRON_FILE.tmp" && mv "$CRON_FILE.tmp" "$CRON_FILE"
    if [ -s "$CRON_FILE" ] && [ "$(tail -c 1 "$CRON_FILE")" != "" ]; then echo "" >> "$CRON_FILE"; fi
    chmod 600 "$CRON_FILE"
    if [ -d "$CRON_SPOOL_DIR" ]; then 
        cp "$CRON_FILE" "$CRON_SPOOL_FILE"
        chmod 600 "$CRON_SPOOL_FILE"
    fi
    if [ -x /opt/etc/init.d/S10cron ]; then /opt/etc/init.d/S10cron restart >/dev/null 2>&1; fi
}

action_verify_cron() {
    header; echo -e "${BOLD}Verifying Crontab Integrity...${RESET}"
    CRON_PATH="/opt/etc/crontab"
    if [ ! -f "$CRON_PATH" ]; then echo -n " -> File missing. Creating... "; touch "$CRON_PATH"; echo -e "${GREEN}Created.${RESET}";
    else echo -e " -> File exists."; fi
    echo -n " -> Cleaning & Fixing Permissions... "
    sanitize_and_reload_cron
    echo -e "${GREEN}Done.${RESET}"
    echo ""; echo -e "${GREEN}Verification Complete.${RESET}"; pause
}

cron_cmd_active() { 
    CMD_STR="$1"
    BASENAME=$(echo "$CMD_STR" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
    [ -z "$BASENAME" ] && BASENAME=$(echo "$CMD_STR" | awk '{print $1}')
    grep -q "$BASENAME" "$CRON_FILE" 
}

get_cron_line() { 
    CMD_STR="$1"
    BASENAME=$(echo "$CMD_STR" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
    [ -z "$BASENAME" ] && BASENAME=$(echo "$CMD_STR" | awk '{print $1}')
    grep "$BASENAME" "$CRON_FILE" | head -n 1
}

interactive_cron_builder() {
    CMD_TO_ADD="$1"
    BASENAME=$(echo "$CMD_TO_ADD" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
    [ -z "$BASENAME" ] && BASENAME=$(echo "$CMD_TO_ADD" | awk '{print $1}')

    if grep -qF "$BASENAME" "$CRON_FILE"; then
        echo -e "${YELLOW}Warning: Existing jobs found for $BASENAME:${RESET}"; grep -F "$BASENAME" "$CRON_FILE"; echo ""
        echo -n "Do you want to REPLACE them with the new schedule? (y/n): "; read -r confirm
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then echo "Operation cancelled."; return; fi
        grep -vF "$BASENAME" "$CRON_FILE" > "$CRON_FILE.tmp" && mv "$CRON_FILE.tmp" "$CRON_FILE"; echo -e "${RED}Old entries removed.${RESET}"
    fi
    echo -e "${CYAN}Configure Schedule ($BASENAME):${RESET}"
    echo " 1. Every X Minutes"
    echo " 2. Every X Hours"
    echo " 3. Daily (Specific Time)"
    echo " 4. Weekly (Specific Day & Time)"
    echo " 5. Monthly (Specific Date & Time)"
    echo -n "Select [1-5]: "; read -r opt
    
    SCHED=""
    case $opt in
        1) 
            echo -n "Minutes (e.g. 10): "; read -r mins
            [ -z "$mins" ] && mins="10"
            SCHED="*/$mins * * * *" 
            ;;
        2) 
            echo -n "Hours (e.g. 1): "; read -r hrs
            [ -z "$hrs" ] && hrs="1"
            SCHED="0 */$hrs * * *" 
            ;;
        3) 
            echo -n "Hour (0-23): "; read -r hh
            echo -n "Minute (0-59): "; read -r mm
            [ -z "$hh" ] && hh="03"
            [ -z "$mm" ] && mm="00"
            SCHED="$mm $hh * * *" 
            ;;
        4)
            echo -n "Day of Week (0=Sun, 1=Mon... 6=Sat): "; read -r dow
            echo -n "Hour (0-23): "; read -r hh
            echo -n "Minute (0-59): "; read -r mm
            [ -z "$dow" ] && dow="0"
            [ -z "$hh" ] && hh="03"
            [ -z "$mm" ] && mm="00"
            SCHED="$mm $hh * * $dow"
            ;;
        5)
            echo -n "Day of Month (1-31): "; read -r dom
            echo -n "Hour (0-23): "; read -r hh
            echo -n "Minute (0-59): "; read -r mm
            [ -z "$dom" ] && dom="1"
            [ -z "$hh" ] && hh="03"
            [ -z "$mm" ] && mm="00"
            SCHED="$mm $hh $dom * *"
            ;;
        *) 
            echo "Invalid. Defaulting to daily 04:00."
            SCHED="0 4 * * *" 
            ;;
    esac
    
    echo -e " -> Adding: ${BOLD}$SCHED $CMD_TO_ADD${RESET}"
    echo "$SCHED $CMD_TO_ADD" >> "$CRON_FILE"
    sanitize_and_reload_cron
    echo -e "    ${GREEN}Scheduled & Cron Reloaded.${RESET}"
}

remove_cron_cmd() {
    CMD_TO_REM="$1"
    BASENAME=$(echo "$CMD_TO_REM" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
    [ -z "$BASENAME" ] && BASENAME=$(echo "$CMD_TO_REM" | awk '{print $1}')
    
    grep -vF "$BASENAME" "$CRON_FILE" > "$CRON_FILE.tmp" && mv "$CRON_FILE.tmp" "$CRON_FILE"; sanitize_and_reload_cron
    echo -e "    ${RED}Removed ($BASENAME) & Cron Reloaded.${RESET}"
}

manage_cron_menu() {
    while true; do
        clear
        echo -e "${BOLD}${BLUE}======================================================${RESET}"
        echo -e "${BOLD}${BLUE}   MANAGE CRON JOBS${RESET}"
        echo -e "${BOLD}${BLUE}======================================================${RESET}"
        echo ""
        
        i=1
        for CMD in "$@"; do
            BASENAME=$(echo "$CMD" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
            [ -z "$BASENAME" ] && BASENAME=$(echo "$CMD" | awk '{print $1}')
            
            if cron_cmd_active "$CMD"; then
                EXISTING=$(get_cron_line "$CMD"); 
                # Parse raw string to 5 fields
                RAW_M=$(echo "$EXISTING" | awk '{print $1}')
                RAW_H=$(echo "$EXISTING" | awk '{print $2}')
                RAW_D=$(echo "$EXISTING" | awk '{print $3}')
                RAW_O=$(echo "$EXISTING" | awk '{print $4}')
                RAW_W=$(echo "$EXISTING" | awk '{print $5}')
                
                READABLE=$(cron_to_human "$RAW_M" "$RAW_H" "$RAW_D" "$RAW_O" "$RAW_W")
                
                echo -e " $i. [${GREEN}ON${RESET}] $BASENAME (${DIM}$READABLE${RESET})"
            else
                echo -e " $i. [${RED}OFF${RESET}] $BASENAME"
            fi
            i=$((i+1))
        done
    
        echo ""; echo " 0. Back"; echo ""
        echo -n "Select Job to Manage: "; read -r sel
        
        if [ "$sel" = "0" ] || [ -z "$sel" ]; then return; fi
        
        idx=1; TARGET_CMD=""
        for CMD in "$@"; do
            if [ "$idx" -eq "$sel" ]; then TARGET_CMD="$CMD"; break; fi
            idx=$((idx+1))
        done
        
        if [ -n "$TARGET_CMD" ]; then
            echo ""
            BASENAME=$(echo "$TARGET_CMD" | grep -oE '/opt/[a-zA-Z0-9_./-]+' | xargs basename 2>/dev/null)
            [ -z "$BASENAME" ] && BASENAME=$(echo "$TARGET_CMD" | awk '{print $1}')
            
            if cron_cmd_active "$TARGET_CMD"; then
                echo -e "Selected: ${BOLD}$BASENAME${RESET} (Active)"
                echo " 1. Edit Schedule"
                echo " 2. Disable / Remove"
                echo " 0. Cancel"
                echo -n "Option: "; read -r subopt
                case $subopt in
                    1) interactive_cron_builder "$TARGET_CMD"; pause ;;
                    2) remove_cron_cmd "$TARGET_CMD"; pause ;;
                esac
            else
                echo -e "Selected: ${BOLD}$BASENAME${RESET} (Inactive)"
                echo " 1. Enable (Configure Schedule)"
                echo " 0. Cancel"
                echo -n "Option: "; read -r subopt
                case $subopt in
                    1) interactive_cron_builder "$TARGET_CMD"; pause ;;
                esac
            fi
        fi
    done
}

# --- ACTIONS ---
action_ping() {
    IFS='|' read -r N P R F <<EOF
$T_PING
EOF
    while true; do
        header
        if [ -f "$P" ]; then VER=$(get_version "$P"); echo -e "$N Status: ${GREEN}Installed (v$VER)${RESET}"; else echo -e "$N Status: ${DIM}Not Installed${RESET}"; fi
        echo ""; echo " 1. Install / Update"
        echo " 2. Manage Cron"
        echo " 3. Configure Settings (Targets & IPv6)"
        echo " 4. Uninstall"
        echo ""; echo " 0. Back"; echo "";
        echo -n "Select: "; read -r op
        case $op in
            1) header; check_and_install_deps "$DEPS_PING"; smart_process "$N" "$P" "$R" "$F"; sanitize_and_reload_cron; 
               if [ -n "$CMD_PING_BASE" ]; then manage_cron_menu "$CMD_PING_BASE $CMD_PING_ARGS"; fi; pause ;;
            2) manage_cron_menu "$CMD_PING_BASE $CMD_PING_ARGS"; ;;
            3) configure_pingtool ;;
            4) header; echo -e "${BOLD}Uninstall $N${RESET}"; echo -n " -> Remove file and cron? (y/n): "; read -r ans
               if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
                   if [ -f "$P" ]; then rm -f "$P"; echo -e "    File removed."; fi
                   remove_cron_cmd "$CMD_PING_BASE"; echo -e "${GREEN}Done.${RESET}"
               fi; pause ;;
            0) return ;;
        esac
    done
}

action_traffic() {
    IFS='|' read -r N P R F <<EOF
$T_VNSTAT
EOF
    while true; do
        header; if [ -f "$P" ]; then VER=$(get_version "$P"); echo -e "$N Status: ${GREEN}Installed (v$VER)${RESET}"; else echo -e "$N Status: ${DIM}Not Installed${RESET}"; fi
        echo ""; echo " 1. Install / Update"; echo " 2. Manage Cron"; echo " 3. Configure Interface (Dashboard/DB)"; echo " 4. Uninstall"; echo "";
        echo " 0. Back"; echo ""; echo -n "Select: "; read -r op
        case $op in
            1) header; check_and_install_deps "$DEPS_VNSTAT"; smart_process "$N" "$P" "$R" "$F"; if [ -n "$CMD_VNSTAT" ]; then manage_cron_menu "$CMD_VNSTAT"; fi; pause ;;
            2) manage_cron_menu "$CMD_VNSTAT"; ;;
            3) configure_traffic ;;
            4) header; echo -e "${BOLD}Uninstall $N${RESET}"; echo -n " -> Remove file and cron? (y/n): "; read -r ans; if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then if [ -f "$P" ]; then rm -f "$P"; echo -e "    File removed."; fi; remove_cron_cmd "$CMD_VNSTAT"; echo -e "${GREEN}Done.${RESET}"; fi; pause ;;
            0) return ;;
        esac
    done
}

action_generic() {
    T_DEF="$1"; T_CMD="$2"; RUN_OPT="$3"
    IFS='|' read -r N P R F <<EOF
$T_DEF
EOF
    while true; do
        header
        if [ -f "$P" ]; then VER=$(get_version "$P"); echo -e "$N Status: ${GREEN}Installed (v$VER)${RESET}"; else echo -e "$N Status: ${DIM}Not Installed${RESET}"; fi
        echo ""; echo " 1. Install / Update"; echo " 2. Manage Cron"; echo " 3. Uninstall";
        if [ "$RUN_OPT" = "yes" ]; then echo " 4. Run Tool (Interactive)"; fi
        echo ""; echo " 0. Back"; echo "";
        echo -n "Select: "; read -r op
        case $op in
            1) header; if [ "$N" = "SMB Backup" ]; then check_and_install_deps "$DEPS_SMB"; fi
               if [ "$N" = "Traffic Manager" ]; then check_and_install_deps "$DEPS_VNSTAT"; fi
               if [ "$N" = "Main Dashboard" ]; then 
                   check_and_install_deps "$DEPS_DASH"
                   smart_process "$N" "$P" "$R" "$F"; sanitize_and_reload_cron; configure_dashboard_extras
               else
                   smart_process "$N" "$P" "$R" "$F"; sanitize_and_reload_cron
               fi
               
               if [ -n "$T_CMD" ]; then manage_cron_menu "$T_CMD"; fi; pause ;;
            2) if [ -n "$T_CMD" ]; then manage_cron_menu "$T_CMD"; else echo "No cron job defined."; pause; fi; ;;
            3) header; echo -e "${BOLD}Uninstall $N${RESET}"; echo -n " -> Remove file and cron? (y/n): "; read -r ans
               if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
                   if [ -f "$P" ]; then rm -f "$P"; echo -e "    File removed."; else echo -e "    File not found."; fi
                   if [ -n "$T_CMD" ]; then remove_cron_cmd "$T_CMD"; fi
                   echo -e "${GREEN}Done.${RESET}"
               fi; pause ;;
            4) if [ "$RUN_OPT" = "yes" ]; then
                   if [ -x "$P" ]; then
                       header
                       run_protected "$P"
                       pause
                   else
                       echo -e "${RED}Tool not found or not executable.${RESET}"
                       pause
                   fi
               fi ;;
            0) return ;;
        esac
    done
}

action_firewall() {
    while true; do
        header; if [ -f "$FW_CORE_LOCAL" ]; then V_CORE=$(get_version "$FW_CORE_LOCAL"); S_MAIN="${GREEN}Installed (v$V_CORE)${RESET}"; else S_MAIN="${DIM}Missing${RESET}"; fi
        echo -e "Firewall Suite Status: $S_MAIN"; echo "";
        echo " 1. Install / Update"; echo " 2. Manage Cron"; echo " 3. Run Manager";
        echo " 4. Run Monitor"; echo " 5. Uninstall Suite"; echo ""; echo " 0. Back"; echo "";
        echo -n "Select: "; read -r op
        case $op in
            1) header; check_and_install_deps "$DEPS_FW"; RES_DEPS=$?
               if [ $RES_DEPS -ne 0 ]; then echo -n " -> Dependencies missing. Continue anyway? (y/n): "; read -r ans; if [ "$ans" != "y" ] && [ "$ans" != "Y" ]; then pause; break; fi; fi
               
               # --- KEY HANDLING ---
               EXISTING_KEY=""
               if [ -s "$KEY_FILE" ]; then EXISTING_KEY=$(cat "$KEY_FILE" | tr -d '[:space:]'); fi
               
               if [ -n "$EXISTING_KEY" ]; then
                   echo -e " -> Found AbuseIPDB Key: ${CYAN}${EXISTING_KEY:0:5}...${RESET} (Preserving)"
               else
                   echo -n " -> Configure AbuseIPDB Key for reports? (y/n): "; read -r ans
                   if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
                       echo -n "    Enter API Key: "; read -r KEY_TO_SET
                       if [ -n "$KEY_TO_SET" ]; then
                           echo -n "$KEY_TO_SET" > "$KEY_FILE"
                           chmod 600 "$KEY_FILE"
                           echo -e "    ${GREEN}Key Saved to $KEY_FILE${RESET}"
                       fi
                   fi
               fi
               
               REPO="$FW_REPO"
               smart_process "Manager" "$BIN_DIR/firewall_manager.sh" $REPO "scripts/firewall_manager.sh"
               smart_process "Monitor" "$BIN_DIR/firewall_monitor" $REPO "scripts/firewall_monitor"
               smart_process "Stats" "$BIN_DIR/firewall_stats.sh" $REPO "scripts/firewall_stats.sh"
               smart_process "Updater" "$BIN_DIR/update_blocklist.sh" $REPO "scripts/update_blocklist.sh"
               smart_process "VPN Scan" "$BIN_DIR/vpn_scan.sh" $REPO "scripts/vpn_scan.sh"
               smart_process "Reporter" "$BIN_DIR/abuse_reporter.sh" $REPO "scripts/abuse_reporter.sh"
               smart_process "Netfilter" "$NDM_DIR/100-firewall.sh" $REPO "scripts/100-firewall.sh"
               smart_process "Init" "$INIT_DIR/S00ipset-load" $REPO "scripts/S00ipset-load"
               
               sanitize_and_reload_cron
               pause ;;
            2) manage_cron_menu "$CMD_FW_STAT" "$CMD_FW_UPD" "$CMD_FW_VPN" "$CMD_ABUSE"; ;;
            3) [ -f "$BIN_DIR/firewall_manager.sh" ] && run_protected "$BIN_DIR/firewall_manager.sh" || { echo "Missing"; sleep 1; };;
            4) [ -f "$BIN_DIR/firewall_monitor" ] && run_protected "$BIN_DIR/firewall_monitor" || { echo "Missing"; sleep 1; };;
            5) header; echo -e "${BOLD}Uninstall Firewall Suite${RESET}"; echo -n " -> Remove ALL scripts and cron jobs? (y/n): "; read -r ans
               if [ "$ans" = "y" ] || [ "$ans" = "Y" ]; then
                   F_LIST="$BIN_DIR/firewall_manager.sh $BIN_DIR/firewall_monitor $BIN_DIR/firewall_stats.sh $BIN_DIR/update_blocklist.sh $BIN_DIR/vpn_scan.sh $BIN_DIR/abuse_reporter.sh $NDM_DIR/100-firewall.sh $INIT_DIR/S00ipset-load"
                   for F in $F_LIST; do if [ -f "$F" ]; then rm -f "$F"; echo -e "    Removed $F"; fi; done
                   remove_cron_cmd "$CMD_FW_STAT"; remove_cron_cmd "$CMD_FW_UPD"; remove_cron_cmd "$CMD_FW_VPN"; remove_cron_cmd "$CMD_ABUSE";
                   echo -e "${GREEN}Uninstalled.${RESET}"
               fi; pause ;;
            0) return ;;
        esac
    done
}

# --- MAIN MENU ---
while true; do
    IFS='|' read -r N P R F <<EOF
$T_VNSTAT
EOF
    if [ -f "$P" ]; then V=$(get_version "$P"); L1="${GREEN}v$V${RESET}"; else L1="${DIM}Missing${RESET}"; fi
    IFS='|' read -r N P R F <<EOF
$T_PING
EOF
    if [ -f "$P" ]; then V=$(get_version "$P"); L2="${GREEN}v$V${RESET}"; else L2="${DIM}Missing${RESET}"; fi
    if [ -f "$FW_CORE_LOCAL" ]; then V=$(get_version "$FW_CORE_LOCAL"); L3="${GREEN}v$V${RESET}"; else L3="${DIM}Missing${RESET}"; fi
    IFS='|' read -r N P R F <<EOF
$T_SMB
EOF
    if [ -f "$P" ]; then V=$(get_version "$P"); [ "$V" = "0.0.0" ] && L4="${GREEN}Installed${RESET}" || L4="${GREEN}v$V${RESET}"; else L4="${DIM}Missing${RESET}"; fi
    IFS='|' read -r N P R F <<EOF
$T_DASH
EOF
    if [ -f "$P" ]; then V=$(get_version "$P"); [ "$V" = "0.0.0" ] && L5="${GREEN}Installed${RESET}" || L5="${GREEN}v$V${RESET}"; else L5="${DIM}Missing${RESET}"; fi

    # --- DYNAMIC STATUS CHECK ---
    
    # 1. Email Status
    if [ -f "$EMAIL_CONF" ] && [ -f "$EMAIL_PW_FILE" ]; then
        EM_STATUS="${GREEN}Configured${RESET}"
    else
        EM_STATUS="${RED}Not Set${RESET}"
    fi

    # 2. Auto-Update Status (Check Cron)
    if cron_cmd_active "$CMD_SELF_UPD"; then
        RAW_LINE=$(get_cron_line "$CMD_SELF_UPD")
        # Extract first 5 fields (the schedule)
        RAW_M=$(echo "$RAW_LINE" | awk '{print $1}')
        RAW_H=$(echo "$RAW_LINE" | awk '{print $2}')
        RAW_D=$(echo "$RAW_LINE" | awk '{print $3}')
        RAW_O=$(echo "$RAW_LINE" | awk '{print $4}')
        RAW_W=$(echo "$RAW_LINE" | awk '{print $5}')
        
        SCHED=$(cron_to_human "$RAW_M" "$RAW_H" "$RAW_D" "$RAW_O" "$RAW_W")
        AU_STATUS="${GREEN}Active${RESET} (${DIM}$SCHED${RESET})"
    else
        AU_STATUS="${DIM}Disabled${RESET}"
    fi

    sanitize_and_reload_cron

    header
    echo -e " ${BOLD}System:${RESET}";
    echo -e " 0. ${CYAN}System Setup${RESET} (Deps & WebServer)"
    echo -e " e. ${CYAN}Email Notifications${RESET} [$EM_STATUS]"
    echo "";
    echo -e " ${BOLD}Tools:${RESET}"
    echo -e " 1. Traffic Manager      [$L1]$UPD_VNSTAT"
    echo -e " 2. Ping Monitor         [$L2]$UPD_PING"
    echo -e " 3. Firewall Suite       [$L3]$UPD_FW"
    echo -e " 4. SMB Backup Tool      [$L4]$UPD_SMB"
    echo -e " 5. Main Dashboard       [$L5]$UPD_DASH"
    echo "";
    echo -e " ${BOLD}Global:${RESET}"
    echo -e " u. Check for Updates (Tools)"
    echo -e " s. ${MAGENTA}Update Keentool (Self)${RESET}"
    echo -e " a. ${CYAN}Auto-Update${RESET}          [$AU_STATUS]"
    echo -e " c. View Crontab"
    echo -e " v. ${CYAN}Verify/Fix Crontab${RESET}"
    echo -e " q. Quit"
    echo "";
    echo -n "Select: "; read choice
    case $choice in
        0) setup_system ;;
        e) configure_email ;;
        1) action_traffic ;;
        2) action_ping ;; 
        3) action_firewall ;;
        4) action_generic "$T_SMB" "$CMD_SMB" "yes" ;;
        5) 
            while true; do
                header
                echo -e "${BOLD}Main Dashboard Manager${RESET}"
                echo "";
                echo " 1. Install / Update"
                echo " 2. Manage Logrotate (Cron)"
                echo " 3. Configure Logging Modules (Syslog & HTML)"
                echo " 4. Uninstall"
                echo "";
                echo " 0. Back"; echo ""; echo -n "Select: "; read d_opt
                case $d_opt in
                    1) check_and_install_deps "$DEPS_DASH"; smart_process "Main Dashboard" "$WEB_ROOT/index.html" "KeenTool" "index.html"; sanitize_and_reload_cron; configure_dashboard_extras; pause ;;
                    2) manage_cron_menu "$CMD_LOGROTATE"; pause ;;
                    3) configure_logging_modules ;;
                    4) echo "Uninstalling..."; rm -f "$WEB_ROOT/index.html"; echo "Done."; pause ;;
                    0) break ;;
                esac
            done
            ;;
        u) perform_global_scan ;;
        s) action_self_update ;;
        a) manage_cron_menu "$CMD_SELF_UPD"; pause ;;
        c) header; cat $CRON_FILE; pause ;;
        v) action_verify_cron ;;
        q) exit 0 ;;
    esac
done
